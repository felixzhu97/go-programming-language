# 第 9 章：共享变量的并发

本章介绍了 Go 语言中共享变量的并发编程技术，包括如何安全地在多个 goroutine 之间共享数据。

## 主要内容

### 1. 竞态条件 (Race Conditions)

- 展示了没有同步的并发访问会导致数据竞争
- 演示了不可预测的结果

### 2. 互斥锁 (Mutex)

- 使用 `sync.Mutex` 保护共享资源
- 确保同一时间只有一个 goroutine 可以访问临界区
- 解决竞态条件问题

### 3. 读写锁 (RWMutex)

- 使用 `sync.RWMutex` 优化读多写少的场景
- 允许多个读操作同时进行
- 写操作与读操作、写操作互斥

### 4. sync.Once

- 确保某个操作只执行一次
- 常用于单例模式和延迟初始化
- 线程安全的一次性初始化

### 5. 原子操作 (Atomic Operations)

- 使用 `sync/atomic` 包进行无锁操作
- 提供了基本数据类型的原子操作
- 性能更好，适合简单的计数器等场景

### 6. 死锁避免

- 银行转账示例演示了死锁问题
- 通过排序锁的顺序来避免死锁
- 良好的并发设计模式

## 运行示例

```bash
# 运行所有示例
go run concurrency.go

# 检测竞态条件
go run -race concurrency.go
```

## 关键概念

### 同步原语对比

| 同步原语 | 适用场景     | 性能       | 复杂度 |
| -------- | ------------ | ---------- | ------ |
| Mutex    | 互斥访问     | 中等       | 简单   |
| RWMutex  | 读多写少     | 读操作更快 | 中等   |
| Atomic   | 简单计数     | 最快       | 简单   |
| Once     | 一次性初始化 | -          | 简单   |

### 最佳实践

1. **优先使用通道**：Go 语言鼓励使用通道进行通信，而不是共享内存
2. **最小化锁的范围**：只保护必要的临界区
3. **避免嵌套锁**：减少死锁的可能性
4. **使用 defer 释放锁**：确保锁被正确释放
5. **使用竞态检测器**：`go run -race` 可以检测竞态条件

### 常见陷阱

1. **忘记释放锁**：使用 defer 确保锁被释放
2. **锁的粒度问题**：锁的范围过大影响性能，过小可能导致竞态条件
3. **死锁**：避免循环等待锁的情况
4. **读写锁的误用**：不要在读锁保护下进行写操作

## 扩展学习

- 深入了解 Go 的内存模型
- 学习无锁数据结构的设计
- 探索更复杂的并发模式
- 了解分布式系统中的并发控制
